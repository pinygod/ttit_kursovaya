class QUIKOnlyClient : IAutoStocksClient
    {
        private Quik _quik;

        private int _port;

        public QUIKOnlyClient()
        {
            _port = Quik.DefaultPort;
            Init();
        }

        public QUIKOnlyClient(int port)
        {
            _port = port;
            Init();
        }

        protected void Init()
        {
            _quik = new Quik(_port, new InMemoryStorage());
            _lastOrderPlacingTimeStamp = DateTime.UtcNow;
            _quik.Events.OnTransReply += Events_OnTransReply;
            //_quik.Events.OnStopOrder += Events_OnStopOrder;
            //_quik.Events.OnOrder += Events_OnOrder;
        }        

        private void Events_OnTransReply(QuikSharp.DataStructures.Transaction.TransactionReply transReply)
        {
            _transResponses[transReply.TransID] = transReply;
        }

        public List<PositionView> GetDepoPositionsRaw()
        {
            var res = new List<PositionView>();
            var depo = _quik.Trading.GetDepoLimits().Result;
            foreach(var p in depo)
            {
                var pos = new PositionView
                {
                    Ticker = p.SecCode,
                    Amount = p.CurrentBalance,
                    LimitKind = PositionView.ParseQUIKLimitKind(p.LimitKind),
                    PositionType = PositionType.Current
                };
                res.Add(pos);
            }
            return res;
        }

        public List<StopOrderView> GetStopOrders()
        {
            var res = new List<StopOrderView>();
            var orders = _quik.StopOrders.GetStopOrders().Result;
            foreach(var o in orders)
            {
                var order = StopOrderView.FromQUIKStopOrder(o);
                res.Add(order);
            }
            return res;
        }

        public bool IsConnectedToClient()
        {
            return !_quik.Service.GetWorkingFolder().Result.IsNullOrEmpty();
        }

        public bool IsConnectedToStocks()
        {
            return _quik.Service.IsConnected().Result;
        }

        public List<PositionView> GetFuturesPositionsRaw()
        {
            var futures = _quik.Trading.GetFuturesClientHoldings().Result;
            var res = new List<PositionView>();
            foreach (var f in futures)
            {
                var pos = new PositionView()
                {
                    Ticker = f.secCode,
                    Amount = (decimal)f.totalNet,
                    LimitKind = PositionView.PositionLimitKind.Unknown
                };
                res.Add(pos);
            }
            return res;
        }

        protected void Log(string msg)
        {
            TradingAutomation.Log.WriteLine(msg);
        }
        private void Log(string msg, string subsection)
        {
            TradingAutomation.Log.WriteLine(msg, subsection);
        }

        protected string GetClassCodeForSecCode(string secCode)
        {
            string classCode;
            try
            {
                //Log($"Detemining the class code for the secCode '{secCode}'");
                classCode = _quik.Class.GetSecurityClass(ConfigManager.GetSecClasses(), secCode).Result;
                if (classCode.IsNullOrEmpty())
                {
                    Log($"WARNING! Class code for the '{secCode}' not found!", "QKCLT.CCDET");
                    return null;
                }
            }
            catch
            {
                Log($"ERROR: error while determining class code for sec code '{secCode}'", "QKCLT.CCDET");
                return null;
            }
            return classCode;
        }

        public QuikSharp.DataStructures.SecurityInfo GetSecurityInfo(string secCode, string classCode)
        {
            var secInfo = _quik.Class.GetSecurityInfo(classCode, secCode).Result;
            if (secInfo == null)
            {
                Log($"ERROR: can't obtain security info for '{secCode}'");
            }
            return secInfo;
        }

        public QuikSharp.DataStructures.SecurityInfo GetSecurityInfo(string secCode)
        {
            var classCode = GetClassCodeForSecCode(secCode);
            if (classCode.IsNullOrEmpty())
                return null;
            return GetSecurityInfo(secCode, classCode);
        }

        public PriceRes GetLastPrice(string secCode, string classCode)
        {
            var priceRes = _quik.Trading.GetParamEx(classCode, secCode, "last").Result;
            if (priceRes.Result != "1")
                return null;
            
            var currencyRes = _quik.Trading.GetParamEx(classCode, secCode, "CURRENCYID").Result;
            string currencyName;
            if (currencyRes.Result != "1")
                //TODO: figure out this clutch:
                if (ConfigManager.GetFuturesSecClasses().Contains(classCode))
                {
                    currencyName = "FUTPOINTS";
                }
                else
                    return null;
            else
                currencyName = currencyRes.ParamImage;


            //currencyRes = _quik.Trading.GetParamEx(classCode, secCode, "CURRENCY").Result;
            //if (currencyRes.Result != "1")
            //    return null;
            return new PriceRes
            {
                Price = decimal.Parse(priceRes.ParamValue.Replace(',', '.'), CultureInfo.InvariantCulture),
                Currency = currencyName
            };
        }

        public PriceRes GetLastPrice(string secCode)
        {
            var classCode = GetClassCodeForSecCode(secCode);
            if (classCode.IsNullOrEmpty())
                return null;
            return GetLastPrice(secCode, classCode);
        }       

        public StopOrderView GetStopOrderState(string orderId)
        {
            var stopOrders = _quik.StopOrders.GetStopOrders().Result;
            var order = stopOrders.FirstOrDefault(x => x.OrderNum == long.Parse(orderId));
            return StopOrderView.FromQUIKStopOrder(order);
        }

        public StopOrderView GetStopOrder(string orderIdStr, bool withLinkedOrder)
        {
            var order = _quik.StopOrders.GetStopOrders().Result.FirstOrDefault(x => x.OrderNum == long.Parse(orderIdStr));
            if (order == null)
                return null;
            var res = StopOrderView.FromQUIKStopOrder(order);
            if(withLinkedOrder && res.LinkedOrderId != null)
            {
                var linkedOrder = GetLimitOrder(res.LinkedOrderId.Value.ToString());
                res.LinkedOrder = linkedOrder;
            }
            else
            {
                res.LinkedOrder = null;
            }
            return res;
        }

        public LimitOrderView GetLimitOrder(string orderId)
        {
            var order = _quik.Orders.GetOrders().Result.FirstOrDefault(x => x.OrderNum == long.Parse(orderId));
            return LimitOrderView.FromQUIKOrder(order);
        }

        public List<LimitOrderView> GetLimitOrders()
        {
            var res = new List<LimitOrderView>();
            var orders = _quik.Orders.GetOrders().Result;
            foreach (var o in orders)
            {
                var order = LimitOrderView.FromQUIKOrder(o);
                res.Add(order);
            }
            return res;
        }

        public CancelOrderResult CancelLimitOrder(string orderIdStr)
        {
            var order = _quik.Orders.GetOrders().Result.FirstOrDefault(x => x.OrderNum == long.Parse(orderIdStr));
            if (order == null)
                return new CancelOrderResult
                {
                    Status = CancelOrderResult.ResultState.OrderNotFound
                };
            var price = order.Price;
            if (order.State == QuikSharp.DataStructures.State.Canceled)
                return new CancelOrderResult
                {
                    OrderPrice = price,
                    Lots = order.Quantity,
                    Status = CancelOrderResult.ResultState.OrderIsCancelled
                };
            if(order.State == QuikSharp.DataStructures.State.Completed)
            {
                return new CancelOrderResult
                {
                    OrderPrice = price,
                    Lots = order.Quantity,
                    Status = CancelOrderResult.ResultState.OrderIsExecuted
                };
            }
            var killRes = _quik.Orders.KillOrder(order).Result;
            if (killRes < 0)
                return new CancelOrderResult
                {
                    OrderPrice = price,
                    Lots = order.Quantity,
                    Status = CancelOrderResult.ResultState.GeneralError
                };

            return new CancelOrderResult
            {
                OrderPrice = price,
                Lots = order.Quantity,
                Status = CancelOrderResult.ResultState.OK
            };
        }

        public CancelOrderResult CancelStopOrder(string stopOrderIdStr)
        {
            var order = _quik.StopOrders.GetStopOrders().Result.FirstOrDefault(x => x.OrderNum == long.Parse(stopOrderIdStr));
            if (order == null)
                return new CancelOrderResult
                {
                    Status = CancelOrderResult.ResultState.OrderNotFound
                };
            var condPrice = order.ConditionPrice2 != 0 ? order.ConditionPrice2 : order.ConditionPrice;
            if (order.State == QuikSharp.DataStructures.State.Canceled)
                return new CancelOrderResult
                {
                    StopLimitCondPrice = condPrice,
                    Lots = order.Quantity,
                    Status = CancelOrderResult.ResultState.OrderIsCancelled
                };
            if(order.State == QuikSharp.DataStructures.State.Completed)
            {
                return new CancelOrderResult
                {
                    StopLimitCondPrice = condPrice,
                    Lots = order.Quantity,
                    Status = CancelOrderResult.ResultState.OrderIsExecuted
                };
            }
            var killRes = _quik.StopOrders.KillStopOrder(order).Result;
            if (killRes < 0)
                return new CancelOrderResult
                {
                    StopLimitCondPrice = condPrice,
                    Lots = order.Quantity,
                    Status = CancelOrderResult.ResultState.GeneralError
                };

            return new CancelOrderResult
            {
                StopLimitCondPrice = condPrice,
                Lots = order.Quantity,
                Status = CancelOrderResult.ResultState.OK
            };
        }

        public PlaceNewOrderResult PlaceNewStopLimitOrder(StopOrderView newStopOrder)
        {
            lock (_placeNewOrderLock)
            {
                var cooldown = (DateTime.UtcNow - _lastOrderPlacingTimeStamp).TotalMilliseconds;
                if (cooldown < ConfigManager.GetQUIKOrderPlacementCooldownMS())
                {
                    Thread.Sleep((int)cooldown);
                    _lastOrderPlacingTimeStamp = DateTime.UtcNow;
                }
                var condPrice = newStopOrder.IsByMarket ? 0 : newStopOrder.StopLimitConditionPrice.Normalize();
                var condPrice2 = newStopOrder.IsByMarket ? newStopOrder.StopLimitConditionPrice.Normalize() : 0;
                var order = new QuikSharp.DataStructures.StopOrder()
                {
                    Account = this.GetAccount(newStopOrder.ClassCode),
                    ClassCode = newStopOrder.ClassCode,
                    SecCode = newStopOrder.Ticker,
                    ConditionPrice = condPrice,
                    ConditionPrice2 = condPrice2,
                    Price = newStopOrder.Price.Normalize(),
                    Quantity = Convert.ToInt32(newStopOrder.Amount),
                    StopOrderType = newStopOrder.IsByMarket ? QuikSharp.DataStructures.StopOrderType.TakeProfitStopLimit : QuikSharp.DataStructures.StopOrderType.StopLimit,
                    Operation = StopOrderView.ConvertToQUIKOperation(newStopOrder.Operation),
                    Offset = 0,
                    OffsetUnit = QuikSharp.DataStructures.OffsetUnits.PERCENTS,
                    Spread = 0,
                    SpreadUnit = QuikSharp.DataStructures.OffsetUnits.PERCENTS,
                };
                var createOrderRes = _quik.StopOrders.CreateStopOrder(order).Result;

                //await for transaction response
                var transId = Math.Abs(createOrderRes);
                var getTransRespTimeoutMs = 400;
                var getTransRespIterations = 40;
                var transResp = Task.Run(() =>
                {
                    for (var i = 0; i < getTransRespIterations; ++i)
                    {
                        if (_transResponses.ContainsKey(transId))
                        {
                            _transResponses.TryRemove(transId, out TransactionReply res);
                            return res;
                        }
                        Thread.Sleep(getTransRespTimeoutMs);
                    }
                    return null;
                }).Result;

                if (transResp == null)
                    return new PlaceNewOrderResult
                    {
                        State = PlaceNewOrderResult.ResultState.CantObtainTransactionResponse,
                        Message = $"Can't obtain created order transaction response for transaction {transId}"
                    };
                if (createOrderRes < 0)
                    return new PlaceNewOrderResult
                    {
                        State = PlaceNewOrderResult.ResultState.GeneralError,
                        Message = $"[{transResp.ErrorCode} {transResp.ResultMsg}]"
                    };
                if (transResp.ErrorCode != 0)
                {
                    if (!transResp.ResultMsg.IsNullOrEmpty())
                    {
                        Log($"Transaction response for new order for '{newStopOrder.Ticker}' ended with error {transResp.ErrorCode} '{transResp.ResultMsg}'");
                        if (ConfigManager.GetOrderAmountLimitIsExceededMessageSubstrs().Any(x => transResp.ResultMsg.Contains(x)))
                        {
                            return new PlaceNewOrderResult
                            {
                                State = PlaceNewOrderResult.ResultState.OrderAmountLimitIsExceeded,
                                Message = $"[{transResp.ErrorCode} {transResp.ResultMsg}]"
                            };
                        }
                    }
                    return new PlaceNewOrderResult
                    {
                        State = PlaceNewOrderResult.ResultState.GeneralError,
                        Message = $"[{transResp.ErrorCode} {transResp.ResultMsg}]"
                    };
                }

                var newOrder = this.GetNewStopOrderByTransactionId(transId).Result;
                if (newOrder == null)
                    return new PlaceNewOrderResult
                    {
                        State = PlaceNewOrderResult.ResultState.CantObtainOrderByTransactionId,
                        Message = $"Can't obtain created order by transaction {transId}"
                    };

                if (newOrder.SecCode != newStopOrder.Ticker)
                {
                    var msg = $"Placed order secCode {newOrder.SecCode} is not equal to requested ticker {newStopOrder.Ticker}. Check by transaction ids: awaited to createdOrderRes {createOrderRes} transaction id {transId} but obtained new order with trans id {newOrder.TransId}";
                    Log($"ERROR! {msg}");
                    return new PlaceNewOrderResult
                    {
                        IsError = true,
                        State = PlaceNewOrderResult.ResultState.GeneralError,
                        Message = msg
                    };
                }

                return new PlaceNewOrderResult
                {
                    State = PlaceNewOrderResult.ResultState.OK,
                    Data = newOrder.OrderNum.ToString()
                };
            }
        }

        private async Task<QuikSharp.DataStructures.StopOrder> GetStopOrderByTransactionId(long transId)
        {
            var stopOrders = await _quik.StopOrders.GetStopOrders();
            if (stopOrders != null)
            {
                var stopOrder = stopOrders.FirstOrDefault(x => x.TransId == transId);
                if (stopOrder != null)
                    return stopOrder;
            }
            return null;
        }

        private ConcurrentDictionary<long, TransactionReply> _transResponses = new ConcurrentDictionary<long, TransactionReply>();
        
        private DateTime _lastOrderPlacingTimeStamp;
        private object _placeNewOrderLock = new object();

        private async Task<QuikSharp.DataStructures.StopOrder> GetNewStopOrderByTransactionId(long transId)
        {
            var attemptsCount = 20;
            Thread.Sleep(100);

            var stopOrder = await GetStopOrderByTransactionId(transId);
            if (stopOrder != null)
                return stopOrder;

            //if stop order wasn't found
            for (var i = 2; i <= attemptsCount; ++i)
            {
                Thread.Sleep(500);
                Log($"Attempt {i}/{attemptsCount} to retrieve new stop order for transaction {transId}...");
                stopOrder = await GetStopOrderByTransactionId(transId);
                if (stopOrder != null)
                    return stopOrder;
            }

            return null;
        }

        private string GetAccount(string classCode)
        {
            return _quik.Class.GetTradeAccount(classCode).Result;
        }

        public PlaceNewOrderResult PlaceNewLimitOrder(LimitOrderView newLimitOrder)
        {
            throw new NotImplementedException();
        }
    }